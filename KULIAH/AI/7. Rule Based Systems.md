# What & Why?
RBS is KBS but uses **rules** as knowledge representation.
Rule = precondition - action

RBS is the simplest and most used solution in real world.

In Hybrid Approach, RBS is used very commonly

**RULE: Logical Implication**
Rules can be written in an IF-THEN format. The CLIPS language (C Language Integrated Production System) can be used for developing RBS.

**Architecture**
Uses the same model as [[6. Knowledge Based Systems#Architecture|KBS]].
- Production memory (long term) stores rules
- Working memory (short term) stores facts and inference results
- Inference/Pattern Matcher, checks facts with rules

**Features**
- Modular - each rules are independent
- Incrementable - rules can be added independently
- Modifiable - old rule can be changed independently

**Rule Inference Methods**
- Forward Chaining
	- Data driven
	- Match LHS
- Backward Chaining
	- Goal driven
	- Match RHS
**Forward vs Backward Chaining**
- Forward - have some facts, then get the conclusion based on that facts
- Backward - have a conclusion, then find facts that supports it

# Forward Chaining
Follows **Recognize-Act** Cycle
![[Pasted image 20251006115948.png|500]]

- Initialize data with facts
- Obtain conflict-set by pattern matching rules which are satisfied by data 
- Select a rule from conflict-set by conflict-resolving strategy
- Fire the selected rule (which will change the facts/data)
- Repeat iteration until termination condition

Conflict-resolution Strategy

| Global control                                         | Local control                                           |
| ------------------------------------------------------ | ------------------------------------------------------- |
| Hardcoded into interpreter and thus domain independent | Must be added by developer because its domain dependent |

Global Control
- Seleciton by order
	- Rule Order - FIFO (First rules are selected first)
	- Fact Recency - LIFO (Last facts are selected first)
- Refactoriness - dont select a rule that has just been applied with the same values (prevent infinite loops)
- Selection by Syntactic Structure of Rule
	- Specificity - select most specific rule first
	
Local Control
Selection by Supplementary Knowledge
- Selection by priority
	- In CLIPS you can (declare salience {n}) which assigns priority to rules
- Selection by meta rules

# Backward Chaining
Starts with a goal, we see the rule to that goal. We compare the rule and try to find it so that each precondition in the rule is fulfilled.

Example:
Facts: A, B, C, D, E
R1: Y, D --> Z
R2: X, B, E --> Y
R3:  A --> X
R4: C --> L
R5: L, M --> N

Question: is Z true? 
- To determine it, the precondition for Z is Y and D.
- We know that D is true, but is Y true?
- Precondition for Y is X, B, and E.
- We know that B and E is true? but is X true? yes 

**Some procedures**
- FINDOUT(goal) - find out if a fact (precondition or goal) is true
- MONITOR(rule) - takes first proposition, then FINDOUT true or not
	- If not true, RULE will not be executed
	- If true, do next preposition until found a FALSE or ends

**Example of Full Process**
![[Pasted image 20251012155305.png|600]]