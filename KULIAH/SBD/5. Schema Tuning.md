- [[#Table Splitting|Table Splitting]]
- [[#Denormalization|Denormalization]]


Tuning is done to minimize heavy workloads by modifying the schema or index in a way that the most accessed data are easy to access

Tuning a schema is guided by workload and redundancy issues. It is called **schema evolution** if done after database is in use.

Can be done in several ways:
- Table Splitting
- Denormalization
# Table Splitting
## Horizontal Splitting
Placing rows in two separate tables, depending on values in columns.
Use if:
- Good for large tables, and if reducing the size will reduce number of [[4. Indexing|index]] pages read.
- Table split is natural separation of the row
- Distributes data over physical media
Example: if there are columns which have active and inactive values, split so teh active is separated from the inactive.
Rasionalization: Inactive are less used
## Vertical Splitting
Placing columns in two separate tables, to isolate attributes used often from those that aren't.
Use if:
- Some columns are accessed more than others
- Wide table

# Denormalization
Can be done with tables or columns. Requires a thorough knowledge of how the data are used.
Improves performance by:
- Minimizing joins
- Reducing foreign keys
- Reducing number of indices
- Precomputing aggregate values
- Reducing table amount

Disadvantage:
- Slow data modification
- Application specific, needs to be reevaluated when application changes
- Can increase table size

Types of Denormalization:
- Adding Redundant Columns
- Adding Derived Columns
- Collapsing Tables
- Duplicating Tables

## Adding Redundant Columns
Eliminate frequent joins by adding columns from another. Ex: table for books which have **`author _id`**, add **`author_name`** from the **`authors`** table so it doesnt need to be joined.
- Requires maintenance of two columns (difficult to modify)
- More disk space

## Adding Derived Columns
Adding a column for derived values so eliminating the needs to calculate aggregate values
- Increase storage needs and require maintenace of changes

## Collapsing Tables
Merging two tables into one to eliminate joins
- Requires **one-to-one** relationship
- Eliminate joins but loses conceptual separation of data

## Duplicating Tables
This is like adding redundant columns, but to an entirely new table not to an existing one.

# Managing Denormalized Data
Integrity of data is ensured using:
- Triggers
- Application Logic
- Batch Reconciliation, synchronize once in a while
Triggers provide the best solution, but costly in performance

# Materialized View
Can help speed up queries, particularly aggregate
Overhead of Materialized View:
- Space
- Maintenance

Since view maintenance is systems responsibillity, and not programmer's, it is preferable to schema.

Helping one transaction type with materialized view may hurt other types, so manual selection of it is tedious.