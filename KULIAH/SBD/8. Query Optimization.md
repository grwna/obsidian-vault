# Introduction
Optimization is the second step of [[7. Query Processing| query processing]]. With the first step being parsing and translation. Cost difference between unoptimized and optimized evaluation plans can be enormous.

We will use this schema for future explanation
![[Pasted image 20250929204249.png|500]]
# Transformation of Relational Expressions
Two expressions are **equivalent** if they generate the same set of tuples on every legal database instance.

>[!note]
>Theta joins are general joins with conditions/comparators.
>Commutative is where left hand operand can be right

**Equivalence Rule** 
1. **Conjunctive selections** can be decomposed into a sequence of normal selections
2. **Selections** are commutative
3. Only the **final projection** matter, which means only one projection is ever needed
4. **Selection** can be combined with cartesian products and theta joins
5. **Theta joins** (including natural joins) are commutative
These rules require you see the expressions
6. Join Associativity
	1. **Natural joins** are associative
	2. Theta joins are associative in a certain specific manner (fuck this shit)
7. **Selection**  distributes over the thera join under the following conditions:
	1. All attributes in $\theta_{0}$ involve only the attributes of one of the expressions being joined
	2. $\theta_{1}$ involves E1 and $\theta_{2}$ involves E2
8. **Projection** distributes over theta join as follows:
	1. if $\theta$ involves only attributes from $L_{1}\cup L_{2}$
	2. Also fuck this shit
Some other bullshit equivalence that you can learn yourself 

**Example**
1. Pushing selections
	This means doing selections as early as possible (lower in the tree) in order to minimize tuple amount when doing other operations later (especially joins).
	
2. Multiple Transformations
	Using multiple transformation

3. Pushing Projection
The **pushing** usually use the rule 7 & 8 

# Choice of Evaluations
The choice for evaluation is not clear-cut. Many factors can affect even seemingly efficient operations can cause other operations to be slower than before.
**Approach**
- Cost based optimization
- Heuristics based optimization
## Cost Based
### Cost based join order
Choose join with small result first. There is a join order optimization using Dynamic Programming.

#### Left Deep Join Tree
Sometimes optimizer only evalutes using **left deep join tree**.
The right-hand side input for each join is a relation not the result of intermediate join (opposed to bushy tree)

Time complexity of optimization with bushy trees is $O(3^n)$
Space complexity $O(2^n)$

If only left deep join trees are considered, the space comp. remains but time becomes: $O(n 2^n)$

#### Interesting Sort Orders
**Interesting** if the sort order could be useful for later operations. Usually this doesnt happen a lot so meh.

## Heuristic Based
Cost based is expensive, so use heuristics to prune choices that must be made.
Some heursitcs are:
- Perform selection early (pushing)
- Perform projection early
- Perform most restrictive selection and joins (smallest results)

### Structure of query optimizers

### Cost Based with Equivalence Rules


# Statistics for Cost Estimation
**Catalog Information**
This contains number of blocks or tuples.

**Histogram**
Visualizes distribution of values
- Equi-width - width
- Equi-depth - same height

**Selection Size Estimation**
Estimate the number of tuples that will be return on selections