- [[#Introduction|Introduction]]
	- [[#Introduction#Query Processing|Query Processing]]
	- [[#Introduction#Cost Measuring|Cost Measuring]]
- [[#Selection|Selection]]
	- [[#Selection#File Scan|File Scan]]
	- [[#Selection#Index Scan|Index Scan]]
	- [[#Selection#Selections Involving Equality|Selections Involving Equality]]
- [[#Sorting|Sorting]]
	- [[#Sorting#External Sort Merge|External Sort Merge]]
- [[#Join|Join]]
- [[#Evaluation of Expressions|Evaluation of Expressions]]
	- [[#Evaluation of Expressions#Approach|Approach]]
	- [[#Evaluation of Expressions#Query Evaluation Plan|Query Evaluation Plan]]
- [[#Mengerjakan Soal|Mengerjakan Soal]]

# Introduction
## Query Processing
Query is proccessed first in the **Parsing and Translation** process. This process works much like compilation, where the query is translated into a **parse tree**, then the syntax is processed.
![[Pasted image 20250928230518.png|500]]
*Query processing diagram*

The optimizer will use statistics to optimize query into what is called an **execution plan**. 
A relational algebra expression may have many equivalent expressions, some of which costs more than other. It is the optimizer's job to choose the most efficient expression.

A **query tree** can be used to visualize a **query evaluation plan**.
![[Pasted image 20250928231817.png|200]]
*Query tree for $\Pi_{salary}(\sigma_{salary<75000}(instructor))$*

## Cost Measuring
Cost is the total time for answering a query. Most predominantly affected by **disk access**, with these components:
- Seeks
- Reads
- Writes
Write is most expensive, because a read is required to verify if the write is succesfull. 
For this course, we will focus on:
- block amount ($b$) and transfer time ($T_{t}$)
- seek amount ($s$) and time ($T_{s}$)
- sending results is ignored

Buffer in main memory also matter. $M$ is amount of memory available.


# Selection
## File Scan
Also known as Linear Search (**A1**), where every record is checked sequentially. Require only **one** seek for the first record.
$$Cost = b_{r} *t_{t}+t_{s}$$
$b_{r}$: num of blocks containing records from relation $r$

If selection is on a **key** attribute, then when the attribute is found, search is stopped. This means on average only **half the block amount** is needed.

## Index Scan
Does search using indices. 
There are several types of index scan

## Selections Involving Equality
#### Primary Index, Equality on Key (A2) 
Retrieve a single record that satisfies the equality.
On a B+ Tree index, the Cost is:
$$Cost = (h_{i}+1)*(t_{t}+t_{s})$$
$h_{i}$ : height of the tree
Explanation: The height is for traversing the tree, the extra **1** is for the final record seek and transfer. All steps require the same amount of block transfer and seek.

#### Primary Index, Equality on Non-Key (A3)
Nonkey here means there could be multiple tuples that satisfies the equality. 
$$Cost=h_{i}*(t_{t}+t_{s})+t_{s}+t_{t}*b$$
$b$ : number of blocks that contain at least **one** tuple that satisfies equality

The difference with A3 is only the final step. Instead of only 1 block transfer, A3 can have multiple. Seek is identical to A2.

####  Secondary Index, Equality on Non-Key (A4)
[[4. Indexing#Secondary Index|Secondary Index]] mean physical storage of data blocks are not sorted by the index.
For secondary index on key, the cost is identical to **A2**. However, for nonkey, there are possibly **n** matching records, which may be on different blocks. This causes it to be more costly than th others.
$$Cost = (h_{i}+n)*(t_{t}+t_{s})$$
$n$ : number of matching records, which may be on different blocks

### Selections Involving Comparisons
Can be implemented using file scan, for index scan the details are such:
#### Primary Index, Comparison (A5)
**Keyword**: Primary index is **sorted**
The process: search for the first occurence that satisfies using index, then search sequentially for the rest. This means the cost is Tree traversal + File Scan.
$$Cost = h_{i}*(t_{t}+t_{s})+t_{s}+t_{t}*b$$
Because index is sorted, $\leq$ and $\geq$ is different (one of them does not require using index to search (only file scan), which one?)
#### Secondary Index, Comparison (A6)
$$Cost = (h_{i}+n)*(t_{t}+t_{s})$$
To make sense od this cost, distribute the $h_{i}$ and $n$.

There are also conjunction, disjunction and negation selection, but its not discussed here.


# Sorting
Importance:
- SQL queries can specify that the output be sorted
- Several operations  is more efficient if the relations are sorted
Relations in memory $\rightarrow$ quick sort
Not in memory $\rightarrow$ external sort-merge (this case is more common)

## External Sort Merge
- Create sorted runs
- Merge runs

The proccess:
**Stage 1**
- Takes some records to fill memory, then sort those records.
- Each sorted group is return to disk.
- Do this multiple times until all records in relation are sorted.
$N$: number of record groups
$M$: number of block in a record(?) (the video says this but idk)
$R_{i}$: ith record group

**Stage 2**
This is quite complex
If $N$=4
Takes one block from R1 put to InputBuff then one block from R2 to InputBuff. Put the lower value to OutBuff. If OutBuff is full, write to disk.
Do this for R3 and R4. Say the first result is R5, and the second R6, do the same sorting process for these (multiple passess).

>[!note]
>If $N\geq M$, multiple merge passes are required

**Cost Analysis**
Block transfers for  **initial run** as well as **in each pass** is $2b_{r}$ (for read and writes, aprox.)

Total Cost: For block transfers and seeks, see *Query Processing Slide page 24-25*


# Join
Several algorithms for join
- Nested-loop
- Block nested-loop
- Indexed nested-loop
- Merge-join
- Hash-join

Examples given uses:
Records: Student - 5.000 | Takes - 10.000
Blocks: Student - 100 | Takes - 400

**Note:** Outer relation is $r$, inner is $s$ (for subscript)
### Nested-Loop
Most naive, but most usable (general)
The nested loop is done for **tuples** of two relations, checking if they satisfy conditions before joining.

**Cost Estimation**
Worst-Case, if only 1 block fits in memory
$$ BlockTransfer = n_{r}*b_{s}+b_{r} $$
$$ Seeks = n_{r}+b_{r} $$
If the smaller relation (out of the two that is joined) fits entirely in memory, put as inner relation and cost becomes:
$b_{r}+b_{s}$  block transfers + 2 seeks

### Block Nested-Loop
Nested loop is done at block level instead of tuples. More efficient than normal nested-loop join.

**Cost Estimation**
Wors case:
$$BlockTransfer = b_{r}*b_{s}+b_{r}$$
$$Seeks=2*b_{r}$$
If smaller relation fit in memory
$b_{r}+b_{s}$ + 2 seeks

### Index Nested-Loop
Index scan can replace file scan if:
- Join is **equality join** or **natural join**.
- Index is available on the inner relation's join attribute

**Cost Estimation**
Worst case: buffer only enough for one page of r, and for each tuple in r, we perform index lookup on s.
$$Cost=b_{r}*(t_{t}+t_{s})+n_{r}*c$$
c is the cost of traversing index and fetching all matching s tuples for one tuple of r.
c can be estimated as cost of a single selection on s using the join condition (height + find actual data/1).

### Merge Join
- Sort both relations on their join attribute (if not)
- Merge the sorted relations to join
- **ONLY** for equality join and natural joins
If $b_{b}$ is size of buffer, the cost is:
Block transfer - $b_{r}+b_{b}$
Seeks - $\lceil b_{r} /b_{b}\rceil+\lceil b_{s} /b_{b}\rceil$

### Hash Join
- Only for equi and natural joins
- A hash function $h$ is used to map Join attributes to {0, 1, ..., n}. Where join attributes are common attributes of r and s in the join.
Basically, how it works is: a tuple is only compared with the other relation of the same partition, because of how hasing works (just read the slides dawg, this is difficult)

Steps:
- Partition $s$ using $h$, then also do $r$
- Build & Probe (important study again later)
	- Has build input (s - inner)
	- Probe input (r - outer)
	- Choose small as build input, so $n$ becomes small
The value n and hash function h is chosen such that si should fit in memory
If n > M, need **recursive partitioning**

**Cost**
Without recursive partitioning: 
Block Transfer - $3(b_{r}+b_{s})+4*n_{h}$
Seeks - $2(\lceil b_{r} /b_{b}\rceil+\lceil b_{s} /b_{b}\rceil)$
The 3 is gotten from partitioning (2) + build and probe (1)
`4*nh` is overhead, however is very small so can be ignored


>[!important]
>How to calculate buffer size?
>Memory size -1 divided by number of partitions Floored
### Complex Joins
Conjunctive - Disjunctive


# Evaluation of Expressions
Ada dua pendekatan untuk evaluasi:
## Approach
### Materialization
Every operations are evaluated then the results are stored (materialized) on disk.
Weakness: require temporary relation on disk.
### Pipelining
Pass on tuples to parent as operations are executed. Think of an assembly line. This means operations are run interleaved. Pipelining does not require storing to disk for the operations.
>[!note]
>Parent process are process higher on the query tree.

## Query Evaluation Plan
Evaluation is done using a tree. 
By default: all edges on the tree are pipelined. However, some operators are always materialized (e.g. hash join)
>[!note]
>Evaluation is the process a DBMS execute query and retrieve data. Evaluation is not done by people/programmers.
### Materialized Evaluation
- Evaluate one operation at a time, starting at the lowest (which will be **relations**)
- Intermediate results materialized into temporary relations are used for the next levels of operations.
- This evaluation is always applicable, but costly. 
	The cost is sum of costs of individual operations + cost of writing intermediate results to disk ~~+ cost of writing final result~~ (ignored)

Number of blocks written out ($b_{r}$) can be estimated as:
$$b_{r}=n_{r}/f_{r}$$
$n_{r}$ : estimated number of tuples in the result relation
$f_{r}$ : **blocking factor** how many tuples fit in one block

The number of seeks are: $\lceil b_{r}/b_{b} \rceil$

### Pipelined Evaluation
Basically evaluating using [[#Pipelining]]. Main drawbacks is that this is **not always applicable**
Also, pipelining requires algorithms so that the tuples can be processed correctly. There are two ways for this:
- demand driven
- producer driven
#### Demand Driven (Lazy)
Each operation requests next tuple from children operations. Its called lazy because only processed when requested.
- Also called pull model of pipelining

#### Producer Driven
Uses buffer to store output until full. Doesnt require requesting.
Push model of pipelining



# Mengerjakan Soal
1. Buat Query Tree (read [Query Tree](https://www.geeksforgeeks.org/dbms/query-tree-in-relational-algebra/))