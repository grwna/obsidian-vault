- [[#Join|Join]]
- [[#Sorting|Sorting]]
# Introduction
## Query Processing
Query is proccessed first in the **Parsing and Translation** process. This process works much like compilation, where the query is translated into a **parse tree**, then the syntax is processed.
![[Pasted image 20250928230518.png|500]]
*Query processing diagram*

The optimizer will use statistics to optimize query into what is called an **execution plan**. 
A relational algebra expression may have many equivalent expressions, some of which costs more than other. It is the optimizer's job to choose the most efficient expression.

A **query tree** can be used to visualize a **query evaluation plan**.
![[Pasted image 20250928231817.png|200]]
*Query tree for $\Pi_{salary}(\sigma_{salary<75000}(instructor))$*

## Cost Measuring
Cost is the total time for answering a query. Most predominantly affected by **disk access**, with these components:
- Seeks
- Reads
- Writes
Write is most expensive, because a read is required to verify if the write is succesfull. 
For this course, we will focus on:
- block amount ($b$) and transfer time ($T_{t}$)
- seek amount ($s$) and time ($T_{s}$)
- sending results is ignored

Buffer in main memory also matter. $M$ is amount of memory available.

# Selection
## File Scan
Also known as Linear Search (**A1**), where every record is checked sequentially. Require only **one** seek for the first record.
$$Cost = b_{r} *t_{t}+t_{s}$$
$b_{r}$: num of blocks containing records from relation $r$

If selection is on a **key** attribute, then when the attribute is found, search is stopped. This means on average only **half the block amount** is needed.

## Index Scan
Does search using indices. 
There are several types of index scan
### Primary Index, Equality on Key (A2) 
Retrieve a single record that satisfies the equality.
On a B+ Tree index, the Cost is:
$$Cost = (h_{i}+1)*(t_{t}+t_{s})$$
$h_{i}$ : height of the tree
Explanation: The height is for traversing the tree, the extra **1** is for the final record seek and transfer. All steps require the same amount of block transfer and seek.

### Primary Index, Equality on Non-Key (A3)
Nonkey here means there could be multiple tuples that satisfies the equality. 
$$Cost=h_{i}*(t_{t}+t_{s})+t_{s}+t_{t}*b$$
$b$ : number of blocks that contain at least **one** tuple that satisfies equality

The difference with A3 is only the final step. Instead of only 1 block transfer, A3 can have multiple. Seek is identical to A2.

### Secondary Index, Equality on Non-Key (A4)
[[4. Indexing#Secondary Index|Secondary Index]] mean physical storage of data blocks are not sorted by the index.
For secondary index on key, the cost is identical to **A2**. However, for nonkey, there are possibly **n** matching records, which may be on different blocks. This causes it to be more costly than th others.
$$Cost = (h_{i}+n)*(t_{t}+t_{s})$$
$n$ : number of matching records, which may be on different blocks

## Selections Involving Comparisons
### Primary Index, Comparison

### Secondary Index, Comparison

# Mengerjakan Soal
1. Buat Query Tree (read [Query Tree](https://www.geeksforgeeks.org/dbms/query-tree-in-relational-algebra/))